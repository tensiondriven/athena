# Claude Constraint Framework: How to Scope AI Work Sessions

*A practical guide for setting effective boundaries and expectations with Claude*

## Overview

Claude doesn't measure time directly but works exceptionally well with structured constraints. This framework helps you scope work sessions effectively and get predictable outcomes.

## üéØ Most Effective Constraint Types

### **Turn-Based** (Highly Recommended)
Claude can count responses precisely and work within defined interaction limits.

**Examples:**
- "5 turns" - Exactly 5 Claude responses
- "3 back-and-forth exchanges" - 6 total messages (3 each)
- "Next 2 messages" - Clear, concrete boundary
- "Spend 10 turns exploring X, then summarize"

**Why it works:** Concrete, measurable, aligns with conversation flow.

### **Iteration-Based** (Very Effective)
Focus on attempt count rather than time.

**Examples:**
- "Try 3 different approaches"
- "Make 2 attempts at fixing this"
- "Iterate twice on this design"
- "Prototype 4 variations, then pick the best"

**Why it works:** Encourages experimentation within bounds.

### **Scope-Based** (Highly Practical)
Define depth and complexity expectations.

**Examples:**
- "Quick fix only" vs "Deep dive"
- "MVP version" vs "Production ready"
- "Proof of concept" vs "Full implementation"
- "Research phase" vs "Implementation phase"

**Why it works:** Sets quality and depth expectations clearly.

## ‚è∞ Time-Based Constraints (Less Precise)

Claude estimates based on task complexity but cannot measure actual time.

**Examples:**
- "10 minutes" - Interpreted as "quick, focused work"
- "Quick task" - Minimal tool usage, simple solution
- "Extended session" - Complex work, multiple approaches
- "Brief exploration" - Surface-level research

**Use when:** You want to convey urgency or effort level rather than precise timing.

## üí° Claude's Internal Framework

### Complexity Levels
- **Simple**: Single tool use, straightforward solutions
- **Moderate**: Multiple tools, some research required
- **Complex**: Extended tool sequences, deep investigation
- **Deep**: Comprehensive analysis, multiple iterations

### Tool Usage Patterns
- **Minimal**: 1-2 tools, direct approach
- **Standard**: 3-5 tools, some parallel operations
- **Intensive**: Many tools, complex sequences, research phases

### Research Depth
- **Surface**: Quick checks, obvious solutions
- **Moderate**: Some investigation, context gathering
- **Comprehensive**: Deep analysis, multiple approaches, thorough documentation

## üéØ Best Practice Combinations

### Effective Constraint Patterns
```
"Spend 3 turns exploring X, then decide"
"Quick 5-minute investigation using 2-3 tools max"
"MVP version in next 2 responses"
"Deep dive for 10 turns, then summarize findings"
"Try 2 approaches, pick one, implement in 3 turns"
```

### Quality + Scope Combinations
```
"Quick prototype" = Simple approach, MVP quality
"Production implementation" = Complex work, thorough testing
"Research spike" = Deep investigation, comprehensive analysis
"Hot fix" = Minimal scope, immediate solution
```

## üìã Recommended Usage Patterns

### Starting Projects
- "Explore for 3 turns, then propose implementation plan"
- "Quick feasibility check in 2 responses"
- "Research phase: 5 turns, then decision point"

### Implementation Sessions
- "MVP in next 4 turns"
- "Implement 3 variations, then refine the best one"
- "Build until it works, max 8 turns"

### Debugging Sessions
- "Quick diagnosis in 2 turns"
- "Try 3 different fixes"
- "Debug for 5 turns, then escalate if needed"

### Research Sessions
- "Deep dive for 10 turns"
- "Surface-level exploration in 3 responses"
- "Compare 4 approaches, then recommend"

## ‚ö° Efficiency Tips

### High-Leverage Constraints
- **Turn limits with quality gates**: "Perfect it in 3 turns"
- **Iteration with decision points**: "Try 2 approaches, then commit"
- **Scope with exit criteria**: "MVP that passes basic tests"

### Avoiding Ineffective Patterns
- ‚ùå "Work on this indefinitely"
- ‚ùå "Make it perfect" (without scope limits)
- ‚ùå "Fix everything" (too broad)
- ‚úÖ "Fix the login bug in 3 turns"
- ‚úÖ "Improve performance, 2 approaches max"

## üîÑ Adaptive Constraints

### Mid-Session Adjustments
```
"Extend this by 3 more turns if needed"
"Switch to quick fix mode if this gets complex"
"Escalate to deep dive if simple approach fails"
```

### Quality Checkpoints
```
"Review after 5 turns, then decide next steps"
"Stop if we hit a good solution early"
"Pause at turn 7 for direction check"
```

## üéØ Summary: The Golden Rules

1. **Turn-based constraints are most effective** - Claude counts precisely
2. **Combine scope + iteration limits** - "MVP in 3 turns"
3. **Set quality expectations upfront** - "Production ready" vs "Quick prototype"
4. **Use checkpoints for longer sessions** - "Review at turn 5"
5. **Adapt based on complexity** - "Simple fix OR deep dive, you choose"

## Examples in Practice

### Software Development
- "Debug this error in 3 turns"
- "Implement user authentication, MVP quality, 5 turns max"
- "Research best practices for 4 turns, then prototype"

### Writing Tasks
- "Draft blog post in 2 turns"
- "Polish this document over 3 iterations"
- "Research and outline in 4 turns, then write"

### Problem Solving
- "Try 3 different solutions"
- "Quick analysis in 2 turns, deep dive if needed"
- "Explore for 5 turns, then recommend approach"

---

*This framework emerges from extensive collaboration patterns between humans and Claude, optimized for maximum productivity and clear expectations.*