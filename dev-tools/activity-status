#!/bin/bash

# Activity Status - Real-time file activity monitor for Athena development
# Shows recent file reads/writes with timing and operation type

PROJECT_ROOT="/Users/j/Code/athena"
REFRESH_RATE=0.33
MAX_FILES=15

format_time_ago() {
    local seconds=$1
    if [ $seconds -lt 60 ]; then
        echo "${seconds}s"
    elif [ $seconds -lt 3600 ]; then
        echo "$((seconds/60))m"
    else
        echo "$((seconds/3600))h"
    fi
}

get_file_activity() {
    # Much faster: only check files modified in last 10 minutes
    local cutoff=$(($(date +%s) - 600))
    local now=$(date +%s)
    
    # Use find with -newer for speed, limit to key directories
    find "$PROJECT_ROOT"/{docs,system,dev-tools} -type f \
        -newermt "@$cutoff" 2>/dev/null | \
    head -$MAX_FILES | \
    while read filepath; do
        local timestamp=$(stat -f '%m' "$filepath" 2>/dev/null || echo 0)
        local ago=$((now - timestamp))
        local basename=$(basename "$filepath")
        local relpath=$(echo "$filepath" | sed "s|$PROJECT_ROOT/||")
        local time_str=$(format_time_ago $ago)
        
        # Determine operation type based on file extension and recency
        local op_type="üìù"  # default to write
        if [[ "$basename" == *".md" ]] && [ $ago -lt 5 ]; then
            op_type="‚úçÔ∏è "  # recent markdown write
        elif [[ "$basename" == *".py" ]] && [ $ago -lt 5 ]; then
            op_type="üêç"  # recent python write
        elif [[ "$basename" == *".json" ]] && [ $ago -lt 5 ]; then
            op_type="üìã"  # recent config write
        elif [ $ago -gt 30 ]; then
            op_type="üëÅÔ∏è "  # older, likely read
        fi
        
        echo "$timestamp $op_type $time_str $relpath"
    done | sort -nr | head -$MAX_FILES | cut -d' ' -f2-
}

get_git_status() {
    cd "$PROJECT_ROOT" 2>/dev/null || return
    local status_output=$(git status --porcelain 2>/dev/null)
    local branch=$(git branch --show-current 2>/dev/null || echo "unknown")
    
    if [ -z "$status_output" ]; then
        echo "üåø $branch (clean)"
    else
        local modified=$(echo "$status_output" | grep -c "^ M" || echo 0)
        local added=$(echo "$status_output" | grep -c "^A" || echo 0)
        local untracked=$(echo "$status_output" | grep -c "^??" || echo 0)
        echo "üî• $branch (M:$modified A:$added ?:$untracked)"
    fi
}

show_header() {
    echo "üîÑ Athena Development Activity Monitor"
    echo "üìÅ Project: $PROJECT_ROOT"
    echo "‚è±Ô∏è  Refresh: ${REFRESH_RATE}s | üìÇ Git: $(get_git_status)"
    echo "----------------------------------------"
    printf "%-3s %-6s %s\n" "OP" "AGO" "FILE"
    echo "----------------------------------------"
}

check_self_update() {
    local script_path="$0"
    local last_modified=$(stat -f '%m' "$script_path" 2>/dev/null || echo 0)
    
    if [ -z "$SCRIPT_LAST_MODIFIED" ]; then
        export SCRIPT_LAST_MODIFIED=$last_modified
    elif [ "$last_modified" -gt "$SCRIPT_LAST_MODIFIED" ]; then
        echo "üîÑ Script updated, restarting..."
        sleep 1  # Brief pause to avoid restart loops
        export SCRIPT_LAST_MODIFIED=$last_modified
        exec "$script_path" "$@"
    fi
}

main() {
    if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
        echo "Usage: $0 [--once]"
        echo ""
        echo "Options:"
        echo "  --once    Show activity once and exit"
        echo "  --help    Show this help"
        echo ""
        echo "Icons:"
        echo "  üìù Write operation (recent)"
        echo "  üëÅÔ∏è  Read operation (older)"
        echo "  ‚úçÔ∏è  Markdown edit"
        echo "  üêç Python edit"
        echo "  üìã Config edit"
        echo ""
        echo "Features:"
        echo "  üîÑ Auto-restarts when script is modified"
        echo "  üìÇ Shows git status (M:modified A:added ?:untracked)"
        echo "  ‚å®Ô∏è  Press 'q' to quit"
        exit 0
    fi
    
    if [ "$1" = "--once" ]; then
        show_header
        get_file_activity
        exit 0
    fi
    
    # Set up non-blocking input
    stty -echo -icanon time 0 min 0
    
    # Continuous monitoring with self-update detection
    while true; do
        check_self_update "$@"
        clear
        show_header
        get_file_activity
        echo ""
        echo "Press 'q' to quit"
        
        # Check for 'q' keypress (non-blocking)
        local key=""
        read -t $REFRESH_RATE key
        if [ "$key" = "q" ]; then
            stty echo icanon  # Restore terminal settings
            echo "üëã Goodbye!"
            exit 0
        fi
    done
}

main "$@"